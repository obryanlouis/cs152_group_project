% This script runs the MD-IDC algorithm on a graph

function [answers] = md_idc_power_law(epsilon, delta, beta, queries, input_database, num_nodes)


% Get the number of queries
num_queries = numel(queries);

% Reshape the input database into a vector
real_database = reshape(input_database, [num_nodes^2, 1]);

% Store a list of answers to the queries
answers = zeros(num_queries, 1);


% Set the step size, threshold, and noise parameters
n = num_nodes^2;
M = 2 * num_nodes;
   % (We have M = 2 * num_nodes b/c
   % num_nodes is the number of nodes in each of the halves of the
   % bi-partite graph)
k = num_queries;
mw_step_size = ((sqrt(log(M)) * log(k / beta) * log(1 / delta))/(epsilon * n))^(1/2);
T = 40 * mw_step_size;
maximal_query = ones(num_nodes^2, 1);
p_star = p / (p - 1);
zeta = group_norm(maximal_query, 2, p_star, num_nodes);
step_size = T / 8 / (zeta^2);
max_potential = group_norm(maximal_query, 2, 1, num_nodes)^2;
B = 8 * zeta^2 / (T^2) * max_potential;


for t=1:num_queries
    % Sample from Laplace noise
    A_t = laplacernd(0, epsilon_0, 1);
    % True response
    query = queries{t};
    a_t = dot(query, real_database) + A_t;
    % Noisy response
end


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%







num_queries = numel(queries);
real_database = reshape(input_database, [num_nodes^2, 1]);
norm_of_real_database = norm(real_database, p);

num_entries = num_nodes ^ 2;
threshold = 40 * sqrt((sqrt(num_nodes)* log(num_queries / beta) * log(1 / delta))/(epsilon * num_entries));
step_size = (threshold / 2) / (4 * zeta ^ 2);
current_output_database = [];




for t=0:num_queries
    
    
    if t == 0
        current_output_database = zeros(num_nodes ^ 2, 1);
    else
        
        query = queries{t};
        
        noise = laplacernd(0, 1/epsilon, 1);
        noisy_difference = dot(query, real_database) + noise - dot(query, current_output_database);
        sign_of_noisy_difference = sign(noisy_difference);
        
        n = num_nodes ^2;
        cvx_begin
            variable x(n)
            %minimize( square_pos(norm(x, p)) - square_pos(norm(current_output_database, p)) - dot(2 * current_output_database, x - current_output_database) - step_size * sign_of_noisy_difference * dot(query, x - current_output_database)  )
            %minimize( group_norm(x, 2, p, num_nodes) - group_norm(x, 2, p, num_nodes) - dot(2 * current_output_database, x - current_output_database) - step_size * sign_of_noisy_difference * dot(query, x - current_output_database)  )
            %minimize( group_norm(x, 2, p, num_nodes) + group_norm(x, 2, p, num_nodes) - 2 * dot(current_output_database, x) - step_size * sign_of_noisy_difference * dot(query, x - current_output_database)  )
            minimize( group_norm(x, 2, p, num_nodes) + group_norm(x, 2, p, num_nodes) - step_size * sign_of_noisy_difference * dot(query, x - current_output_database)  )
            subject to
                norm(x) <= norm_of_real_database
        cvx_end
        
        current_output_database = x;
        
    end
    
end

answers = current_output_database;
end



function [output] = group_norm(database, p, q, num_nodes) 

reshaped_database = reshape(database, [num_nodes, num_nodes]);
norms1 = norms(reshaped_database, p, 2);
output = sum(norms1);

end

